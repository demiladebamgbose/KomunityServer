{"version":3,"sources":["../src/ExpoClient.js"],"names":["BASE_URL","BASE_API_URL","PUSH_NOTIFICATION_CHUNK_LIMIT","ExpoClient","options","_httpAgent","httpAgent","message","sendPushNotificationsAsync","receipts","length","messages","_requestAsync","httpMethod","body","shouldCompress","data","Array","isArray","apiError","Error","chunks","chunk","push","url","sdkVersion","require","version","fetchOptions","method","JSON","stringify","headers","Accept","agent","json","_gzipAsync","Buffer","from","set","response","status","_parseErrorResponseAsync","result","_getTextResponseErrorAsync","errors","_getErrorFromResult","errorData","text","statusCode","errorText","otherErrorData","error","_getErrorFromResultError","others","map","code","details","stack","serverStack","token","startsWith","endsWith","isExpoPushToken","pushNotificationChunkSizeLimit","Promise","resolve","reject","gzip"],"mappings":"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","file":"ExpoClient.js","sourcesContent":["/**\n * expo-server-sdk\n *\n * Use this if you are running Node on your server backend when you are working with Expo\n * https://expo.io\n *\n * @flow\n */\nimport invariant from 'invariant';\nimport fetch, { Headers, Response as FetchResponse } from 'node-fetch';\nimport zlib from 'zlib';\n\nconst BASE_URL = 'https://exp.host';\nconst BASE_API_URL = `${BASE_URL}/--/api/v2`;\n\n/**\n * The max number of push notifications to be sent at once. Since we can't automatically upgrade\n * everyone using this library, we should strongly try not to decrease it.\n */\nconst PUSH_NOTIFICATION_CHUNK_LIMIT = 100;\n\n// TODO: Eventually we'll want to have developers authenticate. Right now it's not necessary because\n// push notifications are the only API we have and the push tokens are secret anyway.\nexport default class ExpoClient {\n  static pushNotificationChunkSizeLimit = PUSH_NOTIFICATION_CHUNK_LIMIT;\n\n  _httpAgent: ?HttpAgent;\n\n  constructor(options: ExpoClientOptions = {}) {\n    this._httpAgent = options.httpAgent;\n  }\n\n  /**\n   * Returns `true` if the token is an Expo push token\n   */\n  static isExpoPushToken(token: ExpoPushToken): boolean {\n    return (\n      typeof token === 'string' &&\n      (token.startsWith('ExponentPushToken[') || token.startsWith('ExpoPushToken[')) &&\n      token.endsWith(']')\n    );\n  }\n\n  /**\n   * Legacy alias for isExpoPushToken\n   */\n  static isExponentPushToken(token: ExpoPushToken): boolean {\n    return ExpoClient.isExpoPushToken(token);\n  }\n\n  /**\n   * Sends the given message to its recipient via a push notification\n   */\n  async sendPushNotificationAsync(message: ExpoPushMessage): Promise<ExpoPushReceipt> {\n    let receipts = await this.sendPushNotificationsAsync([message]);\n    invariant(receipts.length === 1, `Expected exactly one push receipt`);\n    return receipts[0];\n  }\n\n  /**\n   * Sends the given messages to their recipients via push notifications and returns an array of\n   * push receipts. Each receipt corresponds to the message at its respective index (the nth receipt\n   * is for the nth message).\n   *\n   * There is a limit on the number of push notifications you can send at once. Use\n   * `chunkPushNotifications` to divide an array of push notification messages into appropriately\n   * sized chunks.\n   */\n  async sendPushNotificationsAsync(messages: ExpoPushMessage[]): Promise<ExpoPushReceipt[]> {\n    let data = await this._requestAsync(`${BASE_API_URL}/push/send`, {\n      httpMethod: 'post',\n      body: messages,\n      shouldCompress(body) {\n        return body.length > 1024;\n      },\n    });\n\n    if (!Array.isArray(data) || data.length !== messages.length) {\n      let apiError: Object = new Error(\n        `Expected Exponent to respond with ${messages.length} ` +\n          `${messages.length === 1 ? 'receipt' : 'receipts'} but got ` +\n          `${data.length}`\n      );\n      apiError.data = data;\n      throw apiError;\n    }\n\n    return data;\n  }\n\n  chunkPushNotifications(messages: ExpoPushMessage[]): ExpoPushMessage[][] {\n    let chunks = [];\n    let chunk = [];\n    for (let message of messages) {\n      chunk.push(message);\n      if (chunk.length >= PUSH_NOTIFICATION_CHUNK_LIMIT) {\n        chunks.push(chunk);\n        chunk = [];\n      }\n    }\n\n    if (chunk.length) {\n      chunks.push(chunk);\n    }\n\n    return chunks;\n  }\n\n  async _requestAsync(url: string, options: RequestOptions): Promise<*> {\n    let sdkVersion = require('../package.json').version;\n    let fetchOptions = {\n      method: options.httpMethod,\n      body: JSON.stringify(options.body),\n      headers: new Headers({\n        Accept: 'application/json',\n        'Accept-Encoding': 'gzip, deflate',\n        'User-Agent': `expo-server-sdk-node/${sdkVersion}`,\n      }),\n      agent: this._httpAgent,\n    };\n    if (options.body != null) {\n      let json = JSON.stringify(options.body);\n      invariant(json != null, `JSON request body must not be null`);\n      if (options.shouldCompress(json)) {\n        fetchOptions.body = await _gzipAsync(Buffer.from(json));\n        fetchOptions.headers.set('Content-Encoding', 'gzip');\n      } else {\n        fetchOptions.body = json;\n      }\n\n      fetchOptions.headers.set('Content-Type', 'application/json');\n    }\n\n    let response = await fetch(url, fetchOptions);\n\n    if (response.status !== 200) {\n      let apiError = await this._parseErrorResponseAsync(response);\n      throw apiError;\n    }\n\n    // We expect the API response body to be JSON\n    let result: ApiResult;\n    try {\n      result = await response.json();\n    } catch (e) {\n      let apiError = await this._getTextResponseErrorAsync(response);\n      throw apiError;\n    }\n\n    if (result.errors) {\n      let apiError = this._getErrorFromResult(result);\n      throw apiError;\n    }\n\n    return result.data;\n  }\n\n  async _parseErrorResponseAsync(response: FetchResponse): Promise<Error> {\n    let result: ApiResult;\n    try {\n      result = await response.json();\n    } catch (e) {\n      return await this._getTextResponseErrorAsync(response);\n    }\n\n    if (!result.errors || !Array.isArray(result.errors) || !result.errors.length) {\n      let apiError: Object = await this._getTextResponseErrorAsync(response);\n      apiError.errorData = result;\n      return apiError;\n    }\n\n    return this._getErrorFromResult(result);\n  }\n\n  async _getTextResponseErrorAsync(response: FetchResponse): Promise<Error> {\n    let text = await response.text();\n    let apiError: Object = new Error(\n      `Exponent responded with an error with status code ${response.status}: ` + text\n    );\n    apiError.statusCode = response.status;\n    apiError.errorText = text;\n    return apiError;\n  }\n\n  /**\n   * Returns an error for the first API error in the result, with an optional `others` field that\n   * contains any other errors.\n   */\n  _getErrorFromResult(result: ApiResult): Error {\n    invariant(\n      result.errors && result.errors.length > 0,\n      `Expected at least one error from Exponent`\n    );\n    let [errorData, ...otherErrorData] = result.errors;\n    let error: Object = this._getErrorFromResultError(errorData);\n    if (otherErrorData.length) {\n      error.others = otherErrorData.map(data => this._getErrorFromResultError(data));\n    }\n    return error;\n  }\n\n  /**\n   * Returns an error for a single API error\n   */\n  _getErrorFromResultError(errorData: ApiResultError): Error {\n    let error: Object = new Error(errorData.message);\n    error.code = errorData.code;\n\n    if (errorData.details != null) {\n      error.details = errorData.details;\n    }\n\n    if (errorData.stack != null) {\n      error.serverStack = errorData.stack;\n    }\n\n    return error;\n  }\n}\n\nfunction _gzipAsync(data: Buffer): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    zlib.gzip(data, (error, result) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\nexport type ExpoClientOptions = {\n  httpAgent?: HttpAgent,\n};\n\ntype HttpAgent = Object;\n\nexport type ExpoPushToken = string;\n\nexport type ExpoPushMessage = {\n  to: ExpoPushToken,\n  data?: Object,\n  title?: string,\n  body?: string,\n  sound?: 'default' | null,\n  ttl?: number,\n  expiration?: number,\n  priority?: 'default' | 'normal' | 'high',\n  badge?: number,\n};\n\nexport type ExpoPushReceipt = {\n  status: 'ok' | 'error',\n  details?: {\n    error?: 'DeviceNotRegistered' | 'MessageTooBig' | 'MessageRateExceeded',\n  },\n  // Internal field used only by developers working on Expo\n  __debug?: any,\n};\n\ntype RequestOptions = {\n  httpMethod: 'get' | 'post',\n  body?: any,\n  shouldCompress: (body: string) => boolean,\n};\n\ntype ApiResult = {\n  errors?: ApiResultError[],\n  data?: any,\n};\n\ntype ApiResultError = {\n  message: string,\n  code: string,\n  details?: any,\n  stack?: string,\n};\n"]}